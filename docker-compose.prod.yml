# docker-compose.prod.yml
# Не монтируем весь проект;
# контейнер работает как неизменяемый;
# монтируем только данные;
# используем .env
# подключаем Nginx + Flask
# services: верхний раздел,
# где описываются все контейнеры, которые будут запущены
services:
  # flask-app: логическое имя сервиса внутри Docker Compose,
  # и будет показано в docker compose ps (как SERVICE)
  flask-app:
    build: . # сборка образа из Dockerfile в текущей директории (.)
    container_name: flask-app-prod # фактическое имя контейнера в Docker
    # flask-app: 5000  логическое имя сервиса внутри Docker Compose
    expose:
      - "5000" # порт 5000 внутри сети, Nginx обращается к нему
    volumes: # монтирует директорию/файл с хоста внутрь контейнера
      # где: ./app/data — папка на компьютере (архив цитат, логи авторов)
      # /app/app/data — путь внутри контейнера
      # тогда данные не исчезнут при пересборке образа,
      # контейнер можно удалять/пересоздавать, а архив цитат сохранится
      # это главный принцип: контейнеры — временные, данные — постоянные
      - ./app/data:/app/app/data
      # указание файла с переменными окружения: Docker прочитает .env,
      # создаст переменные окружения внутри контейнера
      # и, таким образом, ключи не высвечиваются в коде
    env_file:
      - .env
    # environment: дополнительные переменные окружения, заданные прямо в compose‑файле
    environment:
      # Включает production‑режим
      # в коде можно проверить os.getenv("FLASK_ENV")
      # и менять поведение, например, отключать debug.
      # Важно: переменные из environment дополняют .env,
      # но могут перекрывать значения из .env.
      FLASK_ENV: production
      # политика перезапуска контейнера
    restart: unless-stopped # если контейнер упал — Docker сам его перезапустит
  # список сетей, к которым подключён контейнер
    networks:
      - app-net # имя пользовательской сети, которая создана внизу файла
                # через эту сеть Nginx обращается к flask-app

# Этот блок проверяет жив ли контейнер
    healthcheck:
  # команды проверки
  # статус ответа 200 → healthcheck успешен
  # ошибка или не 2xx → неуспех
  # во Flask у тебя должен быть маршрут:
# @app.route("/healthcheck")
# def healthcheck():
#     return "OK", 200

      test: ["CMD", "wget", "-qO-", "http://localhost:5000/healthcheck"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

  # имя сервиса reverse‑proxy
  # Здесь находится официальный образ Nginx
  nginx:
    image: nginx:alpine # готовый образ из Docker Hub
    # облегчённая сборка на базе Alpine Linux
    # (маленький размер, меньше поверхности атаки)
    container_name: nginx-prod имя контейнера
    # декларация зависимости:
    # Nginx зависит от flask-app
    #он должен дождаться, пока flask-app станет здоровым (healthcheck OK),
    #прежде чем считаться полностью поднятым
    depends_on:
      flask-app:
        condition: service_healthy
    # проброс портов из контейнера наружу (host → container)
    # снаружи - 80/ внутри - 80
    # снаружи: https://your-server:443/внутри: Nginx слушает 443
    ports:
      - "80:80"
      - "443:443"
    volumes:
      # Конфиг Nginx:
      # слева: кастомный в репозитории
      # справа: путь, где Nginx ожидает основной config
      # :ro — read‑only (контейнер не может менять файл, только читать)
      # Это делает поведение Nginx предсказуемым и управляемым из репозитория.
      - ./deploy/nginx/nginx.conf:/etc/nginx/nginx.conf:ro

      # Папка для сертификатов и ключей
      # справа: стандартный путь, где многие утилиты (certbot) ищут сертификаты
      - ./deploy/certs:/etc/letsencrypt
      # служебные данные Let's Encrypt (хранилище, метаданные, временные файлы).
      - ./deploy/certs-data:/var/lib/letsencrypt

      # Логи Nginx
      # все access/error логи Nginx сохраняются в файловую систему хоста
      # удобно: анализировать доступ, искать ошибки, смотреть попытки атак
      - ./deploy/nginx/logs:/var/log/nginx
    # То же, что и у Flask:
    # автоматически поднимается после падения или перезапуска машины
    # не трогается, если остановлен по команде
    restart: unless-stopped
    networks:
      - app-net
# Nginx подключён к той же сети, что и flask-app
# это позволяет писать в конфиге Nginx
# proxy_pass http://flask-app:5000;
networks:
  # именованная сеть, которую Docker Compose создаёт автоматически
  app-net: # app -DNS‑имя контейнера в сети app-net
